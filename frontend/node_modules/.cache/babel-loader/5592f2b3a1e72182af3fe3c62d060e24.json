{"ast":null,"code":"import { focusOn } from './commands';\nimport { getTabbableNodes, contains } from './utils/DOMutils';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\n\nexport var getRelativeFocusable = function (element, scope) {\n  if (!element || !scope || !contains(scope, element)) {\n    return {};\n  }\n\n  var focusables = getTabbableNodes([scope], new Map());\n  var current = focusables.findIndex(function (_a) {\n    var node = _a.node;\n    return node === element;\n  });\n\n  if (current === -1) {\n    // an edge case, when anchor element is not found\n    return undefined;\n  }\n\n  return {\n    prev: focusables[current - 1],\n    next: focusables[current + 1],\n    first: focusables[0],\n    last: focusables[focusables.length - 1]\n  };\n};\n\nvar defaultOptions = function (options) {\n  return Object.assign({\n    scope: document.body,\n    cycle: true\n  }, options);\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\n\n\nexport var focusNextElement = function (fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = defaultOptions(options),\n      scope = _a.scope,\n      cycle = _a.cycle;\n\n  var solution = getRelativeFocusable(fromElement, scope);\n\n  if (!solution) {\n    return;\n  }\n\n  var next = solution.next,\n      first = solution.first;\n  var newTarget = next || cycle && first;\n\n  if (newTarget) {\n    focusOn(newTarget.node, options.focusOptions);\n  }\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\n\nexport var focusPrevElement = function (fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = defaultOptions(options),\n      scope = _a.scope,\n      cycle = _a.cycle;\n\n  var solution = getRelativeFocusable(fromElement, scope);\n\n  if (!solution) {\n    return;\n  }\n\n  var prev = solution.prev,\n      last = solution.last;\n  var newTarget = prev || cycle && last;\n\n  if (newTarget) {\n    focusOn(newTarget.node, options.focusOptions);\n  }\n};","map":{"version":3,"names":["focusOn","getTabbableNodes","contains","getRelativeFocusable","element","scope","focusables","Map","current","findIndex","_a","node","undefined","prev","next","first","last","length","defaultOptions","options","Object","assign","document","body","cycle","focusNextElement","fromElement","solution","newTarget","focusOptions","focusPrevElement"],"sources":["D:/WebApp/app-blog/frontend/node_modules/focus-lock/dist/es2015/sibling.js"],"sourcesContent":["import { focusOn } from './commands';\nimport { getTabbableNodes, contains } from './utils/DOMutils';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\nexport var getRelativeFocusable = function (element, scope) {\n    if (!element || !scope || !contains(scope, element)) {\n        return {};\n    }\n    var focusables = getTabbableNodes([scope], new Map());\n    var current = focusables.findIndex(function (_a) {\n        var node = _a.node;\n        return node === element;\n    });\n    if (current === -1) {\n        // an edge case, when anchor element is not found\n        return undefined;\n    }\n    return {\n        prev: focusables[current - 1],\n        next: focusables[current + 1],\n        first: focusables[0],\n        last: focusables[focusables.length - 1],\n    };\n};\nvar defaultOptions = function (options) {\n    return Object.assign({\n        scope: document.body,\n        cycle: true,\n    }, options);\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusNextElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    var _a = defaultOptions(options), scope = _a.scope, cycle = _a.cycle;\n    var solution = getRelativeFocusable(fromElement, scope);\n    if (!solution) {\n        return;\n    }\n    var next = solution.next, first = solution.first;\n    var newTarget = next || (cycle && first);\n    if (newTarget) {\n        focusOn(newTarget.node, options.focusOptions);\n    }\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusPrevElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    var _a = defaultOptions(options), scope = _a.scope, cycle = _a.cycle;\n    var solution = getRelativeFocusable(fromElement, scope);\n    if (!solution) {\n        return;\n    }\n    var prev = solution.prev, last = solution.last;\n    var newTarget = prev || (cycle && last);\n    if (newTarget) {\n        focusOn(newTarget.node, options.focusOptions);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}